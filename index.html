<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Forty Five - 2人オンライン（単一HTML・安定化＆8短期化修正版）</title>
  <style>
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, 'Hiragino Kaku Gothic ProN', 'Noto Sans JP', 'Yu Gothic UI', 'Yu Gothic', sans-serif; background: #0f172a; color: #e2e8f0; }
    h1, h2, h3 { margin: 0.2rem 0 0.8rem 0; }
    #app { max-width: 1100px; margin: 0 auto; padding: 16px; }
    .app-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
    .header-right { opacity: 0.8; font-size: 12px; }
    .card { background: #111827; border: 1px solid #1f2937; border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); margin-bottom: 12px; }
    .hidden { display: none; }
    .muted { color: #94a3b8; font-size: 12px; }
    .hint { color: #9ca3af; font-size: 12px; }
    .sep { margin: 0 8px; opacity: 0.5; }

    .lobby-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .lobby-col label { display: block; font-size: 14px; margin: 8px 0; }

    input, select, button { padding: 10px 12px; border-radius: 12px; border: 1px solid #374151; background: #0b1220; color: #e2e8f0; outline: none; }
    button { cursor: pointer; }
    button.primary { background: #1d4ed8; border-color: #1d4ed8; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .board { display: grid; grid-template-columns: 1fr 1.2fr 1fr; gap: 12px; }
    .zone h3 { font-size: 16px; margin-bottom: 8px; }

    .cards { display: flex; flex-wrap: wrap; gap: 8px; }
    .cards.single { min-height: 80px; }
    .card-item { width: 70px; height: 96px; border-radius: 12px; border: 1px solid #334155; background: linear-gradient(180deg, #0b1324, #0b1020); display: grid; place-items: center; font-weight: 700; position: relative; }
    .card-item.red { color: #fecaca; }
    .card-item.black { color: #c7d2fe; }
    .card-item.back { background: repeating-linear-gradient(45deg, #0b1020, #0b1020 6px, #0d1328 6px, #0d1328 12px); }
    .card-item.selected { outline: 2px solid #38bdf8; }
    .card-item .badge { position: absolute; top: 4px; right: 4px; font-size: 10px; opacity: 0.8; background: #0b1020; border: 1px solid #334155; border-radius: 8px; padding: 2px 6px; }

    .arena { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 10px; }
    .mystery .cards .card-item { filter: brightness(0.9); }
    .effect-note { margin-top: 6px; color: #fcd34d; min-height: 20px; }

    .panel { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .actions .row { margin-top: 8px; display: flex; gap: 8px; align-items: center; }
    .hand .card-item { cursor: pointer; }

    .log { max-height: 200px; overflow: auto; background: #0b1120; }
    #logView > div { padding: 4px 0; border-bottom: 1px dashed #1f2937; font-size: 13px; }

    .footer { display: flex; justify-content: space-between; align-items: center; }

    .diag { color: #fca5a5; font-size: 13px; }

    @media (max-width: 900px) {
      .lobby-grid { grid-template-columns: 1fr; }
      .board { grid-template-columns: 1fr; }
      .panel { grid-template-columns: 1fr; }
      .card-item { width: 58px; height: 82px; }
    }
  </style>
</head>
<body>
  <div id="app">
    <header class="app-header">
      <h1>Forty Five</h1>
      <div class="header-right"><span id="playerIdTag"></span></div>
    </header>

    <section id="lobby" class="card">
      <h2>ロビー</h2>
      <div class="lobby-grid">
        <div class="lobby-col">
          <h3>部屋を作成</h3>
          <label>あなたの名前
            <input id="creatorName" placeholder="例: Alice" />
          </label>
          <button id="btnCreateRoom">部屋を作る</button>
          <p class="hint">※ ルーム番号だけで参加できます。FirebaseのURL入力は不要（内部で固定）。</p>
          <div id="createdRoomInfo" class="muted"></div>
        </div>
        <div class="lobby-col">
          <h3>部屋に参加</h3>
          <label>あなたの名前
            <input id="joinerName" placeholder="例: Bob" />
          </label>
          <label>部屋番号（6桁）
            <input id="roomCodeJoin" placeholder="例: 483920" />
          </label>
          <button id="btnJoinRoom">参加する</button>
        </div>
      </div>
      <div id="diagLobby" class="diag"></div>
    </section>

    <section id="game" class="hidden">
      <div class="topbar card">
        <div>
          <strong>部屋番号：</strong><span id="roomCodeLabel"></span>
          <span class="sep"></span>
          <strong>あなた：</strong><span id="youLabel"></span>
          <span class="sep"></span>
          <strong>相手：</strong><span id="oppoLabel"></span>
        </div>
        <div>
          <strong>ターン：</strong><span id="turnLabel">-</span> / 9
          <span class="sep"></span>
          <strong>フェーズ：</strong><span id="phaseLabel">-</span>
        </div>
      </div>

      <div class="board">
        <div class="zone card">
          <h3>自陣（あなたの得点）</h3>
          <div id="yourHome" class="cards"></div>
        </div>
        <div class="zone card">
          <h3>場</h3>
          <div class="arena">
            <div>
              <div class="label">あなたの出札</div>
              <div id="yourPlay" class="cards single"></div>
            </div>
            <div>
              <div class="label">相手の出札</div>
              <div id="oppoPlay" class="cards single"></div>
            </div>
          </div>
          <div class="mystery">
            <div class="label">ミステリーカード（裏2枚）</div>
            <div id="mysteryArea" class="cards"></div>
          </div>
          <div id="effectNote" class="effect-note"></div>
        </div>
        <div class="zone card">
          <h3>相手陣（相手の得点）</h3>
          <div id="oppoHome" class="cards"></div>
        </div>
      </div>

      <div class="panel card">
        <div class="hand-panel">
          <h3>手札</h3>
          <div id="handArea" class="cards hand"></div>
          <div id="mustPlayNote" class="muted"></div>
        </div>
        <div class="actions">
          <div>
            <button id="btnCommit" disabled>このカードで出す</button>
            <button id="btnCancel" disabled>選択解除</button>
          </div>
          <div class="row">
            <button id="btnSwapK" title="Kの効果：手札1枚とミステリー1枚を交換（Kを出したターンのみ）" disabled>K効果：交換</button>
            <select id="swapHandSelect" disabled></select>
            <select id="swapMysterySelect" disabled></select>
          </div>
        </div>
      </div>

      <div class="log card">
        <h3>ログ</h3>
        <div id="logView"></div>
      </div>

      <div class="footer card">
        <button id="btnLeave">退出</button>
        <button id="btnRematch" class="primary" disabled>同じ部屋で再戦</button>
      </div>

      <div id="diagGame" class="diag"></div>

      <details id="testsPanel" class="card" style="display:none">
        <summary>開発用テスト（クリックで表示）</summary>
        <div id="testsOutput" class="muted"></div>
      </details>
    </section>
  </div>

  <script>
  // ─────────────────────────────────────────────
  // Forty Five - 2人オンライン（単一HTML / 外部JSなし）
  // 追加修正点：
  //  - 未定義room.logでの push クラッシュを解消（resolveTurn/afterResolutionIfHost 冒頭で安全化）
  //  - 8の指定は「次のターンのみ」→ 該当ターンの決着後に mustPlay を自動クリア
  //  - 既存の防御レンダリング・ログ・セルフテストは維持
  // ─────────────────────────────────────────────

  // ★★★ ここはあなたの Firebase Realtime Database の URL に合わせて設定 ★★★
  const DB_BASE = "https://fortyfive-game-default-rtdb.asia-southeast1.firebasedatabase.app"; // 末尾スラッシュ無し

  // ---------- Utilities ----------
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  function uuid(){ return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{ const r=Math.random()*16|0, v=c==='x'?r:(r&0x3|0x8); return v.toString(16); }); }
  function randint(n){ return Math.floor(Math.random()*n); }
  function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
  const isObj = v => v && typeof v === 'object' && !Array.isArray(v);

  // ---------- Firebase REST minimal ----------
  async function dbGet(path){
    const url = `${DB_BASE}${path}.json`;
    const res = await fetch(url, { method: 'GET' });
    return await res.json(); // NOTE: {error:"Permission denied"} の場合がある
  }
  async function dbSet(path, value){
    const url = `${DB_BASE}${path}.json`;
    const res = await fetch(url, { method: 'PUT', body: JSON.stringify(value) });
    return await res.json();
  }
  async function dbPatch(path, value){
    const url = `${DB_BASE}${path}.json`;
    const res = await fetch(url, { method: 'PATCH', body: JSON.stringify(value) });
    return await res.json();
  }

  // ---------- Game constants ----------
  const RANKS = ['2','8','10','Q','K'];
  const SUITS = ['\u2660','\u2663','\u2665','\u2666']; // ♠, ♣, ♥, ♦
  const RANK_VALUE = { '2': 2, '8': 8, '10': 10, 'Q': 12, 'K': 13 };
  function cardColor(suit){ return (suit === '\u2665' || suit === '\u2666') ? 'red' : 'black'; }
  function makeDeck(){ const deck = []; for(const r of RANKS){ for(const s of SUITS){ deck.push({ r, s }); } } return deck; }
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function cardToText(c){ return `${c.s}${c.r}`; }

  // ---------- App State ----------
  let playerId = localStorage.getItem('ff_playerId') || uuid();
  localStorage.setItem('ff_playerId', playerId);
  $('#playerIdTag').textContent = `PlayerID: ${playerId.slice(0,8)}…`;

  let roomCode = null; // 6桁コード
  let youKey = null;   // 'A' or 'B'
  let isHost = false;
  let polling = false;
  let pollAbort = false;

  // ---------- UI State ----------
  let selectedIndex = null; // index in hand
  let cachedRoom = null;

  // ---------- DOM refs ----------
  const el = {
    lobby: $('#lobby'), game: $('#game'), createdInfo: $('#createdRoomInfo'),
    roomCodeLabel: $('#roomCodeLabel'), youLabel: $('#youLabel'), oppoLabel: $('#oppoLabel'),
    turnLabel: $('#turnLabel'), phaseLabel: $('#phaseLabel'),
    yourHome: $('#yourHome'), oppoHome: $('#oppoHome'), yourPlay: $('#yourPlay'), oppoPlay: $('#oppoPlay'),
    mysteryArea: $('#mysteryArea'), handArea: $('#handArea'), logView: $('#logView'),
    mustPlayNote: $('#mustPlayNote'), effectNote: $('#effectNote'),
    btnCommit: $('#btnCommit'), btnCancel: $('#btnCancel'),
    btnSwapK: $('#btnSwapK'), swapHandSelect: $('#swapHandSelect'), swapMysterySelect: $('#swapMysterySelect'),
    btnLeave: $('#btnLeave'), btnRematch: $('#btnRematch'), diagLobby: $('#diagLobby'), diagGame: $('#diagGame'),
    testsPanel: $('#testsPanel'), testsOutput: $('#testsOutput')
  };

  // ---------- Room Model ----------
  function newRoom(creatorName){
    const deck = shuffle(makeDeck());
    const handA = deck.slice(0,9);
    const handB = deck.slice(9,18);
    const mystery = deck.slice(18); // 2 cards
    return {
      createdAt: Date.now(), hostId: playerId,
      players: { A: { id: playerId, name: creatorName || 'You' }, B: { id: null, name: null } },
      dbVersion: 1, deckHash: Math.random().toString(36).slice(2),
      turn: 1, phase: 'pick', // 'pick','resolved','done'
      hands: { A: handA, B: handB }, home: { A: [], B: [] }, grave: { A: [], B: [] },
      mystery: mystery, plays: { A: null, B: null }, mustPlay: { A: null, B: null },
      pendingEight: null, kSwapWindow: null, winner: null, log: []
    };
  }

  // ---------- Safe helpers ----------
  function asArray(v){ return Array.isArray(v) ? v : []; }
  function safePlayers(p){ return (p && p.A && p.B) ? p : { A: {id:null,name:null}, B:{id:null,name:null} }; }
  function safeHands(h){ return (h && Array.isArray(h.A) && Array.isArray(h.B)) ? h : { A: asArray(h?.A), B: asArray(h?.B) }; }
  function safeHome(h){ return (h && Array.isArray(h.A) && Array.isArray(h.B)) ? h : { A: asArray(h?.A), B: asArray(h?.B) }; }
  function safeGrave(g){ return (g && Array.isArray(g.A) && Array.isArray(g.B)) ? g : { A: asArray(g?.A), B: asArray(g?.B) }; }
  function safePlays(p){ return (p && (p.A===null || isObj(p.A) || Array.isArray(p.A)===false) && (p.B===null || isObj(p.B) || Array.isArray(p.B)===false)) ? p : { A: null, B: null }; }
  function safeMustPlay(m){ return (m && ('A' in m) && ('B' in m)) ? m : { A: null, B: null }; }
  function safeLog(l){ return Array.isArray(l) ? l : []; }

  // ---------- Rendering ----------
  function render(room){
    // DB permission errorなどの検出
    if(room && room.error){
      el.diagGame.textContent = `データベースにアクセスできません（${room.error}）。Firebaseのルールで .read/.write を true にしてください（開発用）。`;
      return;
    }
    if(!room || !isObj(room)){
      el.diagGame.textContent = '部屋データの取得に失敗しました。ネットワークやDB設定を確認してください。';
      return;
    }

    cachedRoom = room;
    el.diagGame.textContent = '';
    el.roomCodeLabel.textContent = roomCode || '';

    // 欠損フィールドを安全に扱う
    const players = safePlayers(room.players);
    const hands   = safeHands(room.hands);
    const home    = safeHome(room.home);
    const grave   = safeGrave(room.grave);
    const plays   = safePlays(room.plays);
    const mustPlay= safeMustPlay(room.mustPlay);
    const mystery = asArray(room.mystery);

    // you/oppo 表示
    const oppoKey = youKey === 'A' ? 'B' : 'A';
    const you = players[youKey] || {name:'(未接続)'};
    const oppo= players[oppoKey] || {name:'(未接続)'};
    el.youLabel.textContent = you?.name || '(未接続)';
    el.oppoLabel.textContent = oppo?.name || '(未接続)';

    // 進行状況
    el.turnLabel.textContent = room.turn ?? '-';
    el.phaseLabel.textContent = room.phase ?? '-';

    // 盤面描画（欠損でも落ちない）
    drawCards(el.yourHome, home[youKey] || []);
    drawCards(el.oppoHome, home[oppoKey] || []);
    drawCards(el.yourPlay, (plays[youKey] && plays[youKey].card) ? [plays[youKey].card] : []);
    drawCards(el.oppoPlay, (plays[oppoKey] && plays[oppoKey].card) ? [plays[oppoKey].card] : []);
    drawCards(el.mysteryArea, mystery.map(()=>({back:true})));

    const yourHand = hands[youKey] || [];
    drawHand(el.handArea, yourHand);

    const mp = mustPlay[youKey] || null;
    el.mustPlayNote.textContent = mp ? `※ 次の出札は「${mp}」のみ可（8の効果）` : '';

    el.effectNote.textContent = room.pendingEight
      ? `次ターン：${room.pendingEight==='A'?'プレイヤーA':'プレイヤーB'}の「8」の効果で相手のカード指定`
      : '';

    // ボタン活性
    const canCommit = selectedIndex !== null && room.phase === 'pick'
      && (!mp || (yourHand[selectedIndex] && yourHand[selectedIndex].r === mp))
      && !plays[youKey];
    el.btnCommit.disabled = !canCommit;
    el.btnCancel.disabled = selectedIndex === null;

    const kTurn = room.kSwapWindow === youKey;
    el.btnSwapK.disabled = !kTurn; el.swapHandSelect.disabled = !kTurn; el.swapMysterySelect.disabled = !kTurn;
    buildSwapSelectors({ hands, mystery });

    // リマッチ（ホストのみ・終了時）
    el.btnRematch.disabled = !(room.phase === 'done' && isHost);

    // ログ
    const lines = Array.isArray(room.log) ? room.log : [];
    el.logView.innerHTML = lines.map(line => `<div>${escapeHtml(String(line))}</div>`).join('');
  }

  function drawCards(container, cards){
    container.innerHTML = '';
    const list = Array.isArray(cards) ? cards : [];
    for(const c of list){
      const div = document.createElement('div');
      const cls = c.back ? 'back' : (cardColor(c.s)==='red'?'red':'black');
      div.className = 'card-item ' + cls;
      div.textContent = c.back ? '' : `${c.s}${c.r}`;
      container.appendChild(div);
    }
  }

  function drawHand(container, hand){
    container.innerHTML = '';
    const list = Array.isArray(hand) ? hand : [];
    list.forEach((c, idx)=>{
      const div = document.createElement('div');
      div.className = 'card-item ' + (cardColor(c.s)==='red'?'red':'black');
      if(selectedIndex === idx) div.classList.add('selected');
      div.innerHTML = `<span class="badge">${idx+1}</span>${c.s}${c.r}`;
      div.addEventListener('click', ()=>{
        if(!cachedRoom || cachedRoom.phase !== 'pick') return;
        const mp = (cachedRoom.mustPlay && cachedRoom.mustPlay[youKey]) || null;
        if(mp && c.r !== mp) return;
        if(cachedRoom.plays && cachedRoom.plays[youKey]) return; // already committed
        selectedIndex = (selectedIndex===idx ? null : idx);
        render(cachedRoom);
      });
      container.appendChild(div);
    });
  }

  function buildSwapSelectors(room){
    const yourHand = (room.hands && room.hands[youKey]) ? room.hands[youKey] : [];
    el.swapHandSelect.innerHTML = yourHand.map((c,i)=>(`<option value="${i}">${i+1}: ${c.s}${c.r}</option>`)).join('');
    const mz = Array.isArray(room.mystery) ? room.mystery : [];
    el.swapMysterySelect.innerHTML = mz.map((_,i)=>(`<option value="${i}">謎${i+1}</option>`)).join('');
  }

  function escapeHtml(str){
    return String(str).replace(/[&<>"']/g, s=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;' }[s]));
  }

  // ---------- Game Resolution ----------
  function resolveTurn(room){
    const playA = room.plays?.A; const playB = room.plays?.B;
    if(!playA || !playB){ return room; }

    // まずログの安全化（未定義 push クラッシュ対策）
    room.log = safeLog(room.log);

    const cardA = playA.card; const cardB = playB.card;
    room.kSwapWindow = null;

    const aPlayed8 = cardA.r === '8'; const bPlayed8 = cardB.r === '8';
    const aPlayedK = cardA.r === 'K'; const bPlayedK = cardB.r === 'K';

    // Kの権利者を決める（同時はランダム）
    let kOwner = null;
    if(aPlayedK && bPlayedK){ kOwner = (Math.random()<0.5 ? 'A' : 'B'); room.log.push(`K同時：ランダムで${kOwner}がK効果の権利を得た。`); }
    else if(aPlayedK){ kOwner = 'A'; } else if(bPlayedK){ kOwner = 'B'; }
    if(kOwner){ room.kSwapWindow = kOwner; }

    // 8の権利者（同時はランダム）
    let eightOwner = null;
    if(aPlayed8 && bPlayed8){ eightOwner = (Math.random()<0.5 ? 'A' : 'B'); room.log.push(`8同時：ランダムで${eightOwner}の8効果が有効。`); }
    else if(aPlayed8){ eightOwner = 'A'; } else if(bPlayed8){ eightOwner = 'B'; }

    // 勝敗
    const winner = decideWinner(cardA, cardB); room.winner = winner;
    // home/grave の安全化
    room.home = safeHome(room.home);
    room.grave = safeGrave(room.grave);

    if(winner === 'draw'){
      room.home.A.push(cardA); room.home.B.push(cardB);
      room.log.push('引き分け：双方のカードを自陣に加えた。');
    } else if(winner === 'A'){
      room.home.A.push(cardA, cardB); room.grave.B.push(cardB);
      room.log.push(`Aの勝ち：${cardToText(cardA)} vs ${cardToText(cardB)}。`);
    } else if(winner === 'B'){
      room.home.B.push(cardA, cardB); room.grave.A.push(cardA);
      room.log.push(`Bの勝ち：${cardToText(cardB)} vs ${cardToText(cardA)}。`);
    }

    // 手札から削除（安全に）
    room.hands = safeHands(room.hands);
    if(Number.isInteger(playA.handIndex)) room.hands.A.splice(playA.handIndex, 1);
    if(Number.isInteger(playB.handIndex)) room.hands.B.splice(playB.handIndex, 1);

    // 次ターン用の8
    room.pendingEight = eightOwner;
    room.plays = { A: null, B: null };

    // ▼ 8の指定は「次のターンのみ」→ 今ターンの解決が終わったら mustPlay を必ず解除
    room.mustPlay = safeMustPlay(room.mustPlay);
    room.mustPlay.A = null; room.mustPlay.B = null;

    if(room.turn >= 9){
      room.phase = 'done';
      const aScore = room.home.A.length; const bScore = room.home.B.length;
      const res = aScore === bScore ? 'draw' : (aScore > bScore ? 'A' : 'B');
      room.log.push(`試合終了：A=${aScore}枚, B=${bScore}枚 → ${res==='draw'?'引き分け':res+'の勝利'}`);
      return room;
    }

    room.phase = 'resolved'; room.turn = (room.turn||1) + 1; return room;
  }

  function decideWinner(a, b){
    if(a.r === 'Q' && b.r === 'K') return 'A';
    if(b.r === 'Q' && a.r === 'K') return 'B';
    if(a.r === '10' && cardColor(a.s) === cardColor(b.s)) return 'A';
    if(b.r === '10' && cardColor(a.s) === cardColor(b.s)) return 'B';
    const sum = RANK_VALUE[a.r] + RANK_VALUE[b.r];
    if(a.r === '2' && sum >= 14) return 'A';
    if(b.r === '2' && sum >= 14) return 'B';
    const va = RANK_VALUE[a.r]; const vb = RANK_VALUE[b.r];
    if(va === vb) return 'draw';
    return va > vb ? 'A' : 'B';
  }

  // ---------- Phase transitions (host) ----------
  async function afterResolutionIfHost(room){
    if(room.kSwapWindow){ return; } // K交換待ち

    // ログの安全化
    room.log = safeLog(room.log);

    if(room.pendingEight){
      const owner = room.pendingEight; const target = owner === 'A' ? 'B' : 'A';
      const forced = (owner==='A' ? (room.lastForceRankA || null) : (room.lastForceRankB || null));
      if(forced){
        room.mustPlay = safeMustPlay(room.mustPlay);
        room.mustPlay[target] = forced;
        room.log.push(`${owner}の8効果：次ターン、${target}は「${forced}」を出札指定。`);
      }
      room.pendingEight = null; room.lastForceRankA = null; room.lastForceRankB = null;
    }
    room.phase = 'pick'; await dbSet(`/rooms/${roomCode}`, room);
  }

  // ---------- Events ----------
  $('#btnCreateRoom').addEventListener('click', async ()=>{
    el.diagLobby.textContent = '';
    const name = $('#creatorName').value.trim() || 'Host';
    roomCode = String(Math.floor(100000 + Math.random()*900000));
    isHost = true; youKey = 'A';
    const room = newRoom(name);
    const res = await dbSet(`/rooms/${roomCode}`, room);
    if(res && res.error){ el.diagLobby.textContent = `部屋作成に失敗（${res.error}）。Realtime Databaseのルールを確認してください。`; return; }
    $('#createdRoomInfo').textContent = `部屋番号：${roomCode} を相手に共有してください。`;
    enterGame(room); startPolling();
  });

  $('#btnJoinRoom').addEventListener('click', async ()=>{
    el.diagLobby.textContent = '';
    const name = $('#joinerName').value.trim() || 'Guest';
    const code = $('#roomCodeJoin').value.trim();
    if(!code){ alert('部屋番号を入力してください'); return; }
    roomCode = code;
    const room = await dbGet(`/rooms/${roomCode}`);
    if(!room || room.error){ el.diagLobby.textContent = !room ? '部屋が見つかりません' : `参加失敗（${room.error}）`; return; }
    if(room.players && room.players.B && room.players.B.id && room.players.B.id !== playerId){ alert('この部屋は満員です'); return; }
    room.players = safePlayers(room.players);
    room.players.B.id = playerId; room.players.B.name = name;
    const res = await dbSet(`/rooms/${roomCode}`, room);
    if(res && res.error){ el.diagLobby.textContent = `入室に失敗（${res.error}）`; return; }
    isHost = (room.hostId === playerId); youKey = 'B';
    enterGame(room); startPolling();
  });

  function enterGame(room){ $('#lobby').classList.add('hidden'); $('#game').classList.remove('hidden'); render(room); }

  async function startPolling(){
    if(polling) return; polling = true; pollAbort = false;
    while(!pollAbort){
      try{
        const room = await dbGet(`/rooms/${roomCode}`);
        if(room){
          render(room);
          if(isHost){
            if(room.phase === 'pick' && room.plays && room.plays.A && room.plays.B){
              const updated = resolveTurn(room); await dbSet(`/rooms/${roomCode}`, updated);
            } else if(room.phase === 'resolved'){
              if(!room.kSwapWindow){ await afterResolutionIfHost(room); }
            }
          }
        }
      }catch(e){ console.error(e); }
      await sleep(1100);
    }
    polling = false;
  }

  $('#btnCommit').addEventListener('click', async ()=>{
    if(selectedIndex === null) return;
    const room = await dbGet(`/rooms/${roomCode}`);
    if(!room || room.phase !== 'pick'){ return; }
    if(!room.hands || !room.hands[youKey]){ alert('手札情報が壊れています。再入室してください。'); return; }
    const hand = room.hands[youKey];
    const c = hand[selectedIndex];
    if(!c){ alert('選択したカードが見つかりません'); return; }
    const playData = { handIndex: selectedIndex, card: c };

    if(c.r === '8'){
      const chosen = prompt('相手に指定するカード（2 / 8 / 10 / Q / K）を入力', 'Q');
      const ok = ['2','8','10','Q','K'];
      const forced = ok.includes((chosen||'').toUpperCase()) ? (chosen||'').toUpperCase() : 'Q';
      if(youKey==='A') room.lastForceRankA = forced; else room.lastForceRankB = forced;
      room.log = safeLog(room.log);
      room.log.push(`${youKey}は8を出し、次ターンの指定候補に「${forced}」を選択。`);
    }

    room.plays = room.plays || {A:null,B:null};
    room.plays[youKey] = playData;
    await dbSet(`/rooms/${roomCode}`, room);
    selectedIndex = null;
  });

  $('#btnCancel').addEventListener('click', ()=>{ selectedIndex = null; if(cachedRoom) render(cachedRoom); });

  $('#btnSwapK').addEventListener('click', async ()=>{
    const room = await dbGet(`/rooms/${roomCode}`);
    if(!room || room.phase !== 'resolved' || room.kSwapWindow !== youKey) return;
    const hi = parseInt($('#swapHandSelect').value,10);
    const mi = parseInt($('#swapMysterySelect').value,10);
    if(isNaN(hi) || isNaN(mi)) return;
    room.hands = safeHands(room.hands);
    room.mystery = asArray(room.mystery);
    if(!room.hands[youKey][hi] || !room.mystery[mi]) return;
    const tmp = room.hands[youKey][hi]; room.hands[youKey][hi] = room.mystery[mi]; room.mystery[mi] = tmp;
    room.log = safeLog(room.log);
    room.log.push(`${youKey}がK効果で手札とミステリーを交換。`);
    room.kSwapWindow = null;
    await dbSet(`/rooms/${roomCode}`, room);
  });

  $('#btnLeave').addEventListener('click', async ()=>{
    if(roomCode){
      try{
        const room = await dbGet(`/rooms/${roomCode}`);
        if(room && !room.error){
          room.players = safePlayers(room.players);
          if(youKey==='A'){ room.players.A.id = null; room.players.A.name = null; } else { room.players.B.id = null; room.players.B.name = null; }
          await dbSet(`/rooms/${roomCode}`, room);
        }
      }catch(_){ }
    }
    pollAbort = true; location.reload();
  });

  $('#btnRematch').addEventListener('click', async ()=>{
    const room = await dbGet(`/rooms/${roomCode}`);
    if(!room || room.phase !== 'done') return;
    if(!isHost){ alert('ホストのみが再戦を開始できます'); return; }
    const nameA = (room.players && room.players.A && room.players.A.name) || 'A';
    const nameB = (room.players && room.players.B && room.players.B.name) || 'B';
    const fresh = newRoom(nameA); fresh.players.B.id = room.players?.B?.id || null; fresh.players.B.name = nameB;
    await dbSet(`/rooms/${roomCode}`, fresh);
  });

  window.addEventListener('beforeunload', ()=>{ pollAbort = true; });

  // ---------- Self tests (no network) ----------
  (function runSelfTests(){
    const out = [];
    const ok = (name, cond) => { out.push((cond? '✅':'❌') + ' ' + name); return !!cond; };
    try {
      // decideWinner tests
      ok('QはKに勝つ (Q♠ vs K♥ → A)', decideWinner({r:'Q',s:'\u2660'}, {r:'K',s:'\u2665'}) === 'A');
      ok('10は同色に勝つ (10♠ vs 2♣ → A)', decideWinner({r:'10',s:'\u2660'}, {r:'2',s:'\u2663'}) === 'A');
      ok('2は合計14以上で勝つ (2♦ + K♣ → A)', decideWinner({r:'2',s:'\u2666'}, {r:'K',s:'\u2663'}) === 'A');
      ok('同値は引き分け (8♥ vs 8♣ → draw)', decideWinner({r:'8',s:'\u2665'}, {r:'8',s:'\u2663'}) === 'draw');

      // render defensive (home欠損の部屋でも落ちない)
      youKey = 'A';
      const mockRoom = { players:{A:{name:'A'},B:{name:'B'}}, turn:1, phase:'pick', hands:{A:[],B:[]}, home: undefined, grave:{A:[],B:[]}, plays:{A:null,B:null}, mystery:[], mustPlay:{A:null,B:null}, log:[] };
      render(mockRoom); // 例外が出ないことを確認
      ok('renderはhome欠損でもクラッシュしない', true);

      // ▼ 新規テスト：log未定義でもresolveTurnが例外を出さない
      const roomNoLog = { turn:1, phase:'pick', hands:{A:[{r:'Q',s:'\u2660'}], B:[{r:'K',s:'\u2665'}]}, home:{A:[],B:[]}, grave:{A:[],B:[]}, plays:{A:{handIndex:0,card:{r:'Q',s:'\u2660'}}, B:{handIndex:0,card:{r:'K',s:'\u2665'}}}, mystery:[] };
      try { resolveTurn(roomNoLog); ok('resolveTurn: room.log未定義でクラッシュしない', true); } catch(e){ ok('resolveTurn: room.log未定義でクラッシュしない', false); }

      // ▼ 新規テスト：8の mustPlay は次のターンのみ
      const roomMust = { turn:1, phase:'pick', hands:{A:[{r:'8',s:'\u2660'}], B:[{r:'Q',s:'\u2665'}]}, home:{A:[],B:[]}, grave:{A:[],B:[]}, plays:{A:{handIndex:0,card:{r:'8',s:'\u2660'}}, B:{handIndex:0,card:{r:'Q',s:'\u2665'}}}, mustPlay:{A:null,B:'Q'}, log:[], mystery:[], lastForceRankA:'Q' };
      const after = resolveTurn(roomMust);
      ok('resolve後にmustPlayがクリアされる(A/Bともnull)', after.mustPlay.A===null && after.mustPlay.B===null);

    } catch (e){
      out.push('❌ テスト中に例外: ' + e.message);
    }

    // 出力
    if(out.some(line=>line.startsWith('❌')) || /[?&]test=1/.test(location.search) || location.hash==="#test"){
      el.testsPanel.style.display = '';
    }
    el.testsOutput.innerHTML = out.map(x=>`<div>${escapeHtml(x)}</div>`).join('');
    console.log('[SelfTests]', out.join('\n'));
  })();

  </script>
</body>
</html>
